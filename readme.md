# Sistema de Reserva de Assentos em Cinema 

## Proposi√ß√£o do Problema

O objetivo desta documenta√ß√£o √© apresentar o desenvolvimento do backend de um sistema de reserva de assentos para sess√µes de cinema. Al√©m de abordar a modelagem de dados e a implementa√ß√£o da API, este documento discute os principais desafios de concorr√™ncia enfrentados durante o desenvolvimento e as estrat√©gias adotadas para garantir transa√ß√µes seguras em banco de dados relacionais.

## Cen√°rio

Em cinemas tradicionais, a venda de ingressos era feita presencialmente, o que frequentemente resultava em confus√µes, especialmente em hor√°rios de pico. Problemas como dupla reserva de assentos eram comuns.  
Para solucionar isso, foi proposto o desenvolvimento de um sistema online de reserva de assentos, com controle rigoroso de disponibilidade em tempo real. 

## Especifica√ß√£o T√©cnica

A seguir, detalhamos o banco de dados relacional utilizado (MariaDB), sua modelagem de tabelas e a estrutura da API desenvolvida com FastAPI. Por fim, abordamos os desafios relacionados √† concorr√™ncia e as solu√ß√µes implementadas.

### Banco de Dados e Modelagem

Escolhemos o Mariadb como Banco de Dados pois √© open-source e possui uma comunidade robusta, o que torna mais acess√≠vel para o projeto e contribui para sua evolu√ß√£o cont√≠nua.

Feita a Modelagem, o Banco possui seguintes tabelas:

| Tabela          | Colunas                                                          |
|-----------------|------------------------------------------------------------------|
| Filmes          | ID (PK), Titulo, Duracao, Formato                                |
| Salas           | ID (PK), Nome                                                    |
| Sessoes         | ID (PK), Filme_ID (FK), Sala_ID (FK), Horario, Preco             |
| Agenda_Sessao   | ID (PK), Sessao_ID (FK), Data_Sessao                             |
| Usuarios        | ID (PK), Nome, Email                                             |
| Assentos        | ID (PK), Numero, Sala_ID (FK)                                    |
| Reservas        | ID (PK), Usuario_ID (FK), Agenda_Sessao_ID (FK), Assento_ID (FK) |

Descri√ß√£o de cada tabela do Banco de Dados:

- **Filmes**: Tabela que cont√©m os filmes que est√£o em cartaz no cinema.  
- **Salas**: Tabela com os nomes de cada sala, funciona como uma tabela auxiliar.  
- **Sessoes**: Tabela que cont√©m as sess√µes que cada filme pode passar.  
- **Agenda_Sessao**: S√£o as datas de cada sess√£o.  
- **Usuarios**: Tabela que cont√©m os clientes que fazem a compra dos ingressos.  
- **Assentos**: Tabela com os assentos de cada sala.  
- **Reservas**: Tabela que guarda a reserva que um determinado usu√°rio fez de um assento para uma determinada sess√£o.

---

## API Backend: FastAPI

A API foi desenvolvida em FastAPI devido √† sua performance, suporte a valida√ß√£o autom√°tica com Pydantic, e facilidade de integra√ß√£o com Swagger. 

**Os principais endpoints criados incluem:**

- `/sessoes`: Lista as sess√µes com seus respectivos filmes. (GET) ‚úÖ  
- `/fazer-reserva`: Reserva um assento para uma sess√£o espec√≠fica. (POST) üîÑ  
- `/mostrar-reservas`: Mostra todas as reservas de uma determinada sess√£o (GET)  
- `/alterar-reserva`: Altera uma reserva feita por um usu√°rio espec√≠fico. (POST) ‚úÖ  
- `/deletar-reserva`: Deleta um assento para uma sess√£o espec√≠fica. (GET)  
- `/assentos`: Exibe assentos dispon√≠veis para uma sess√£o espec√≠fica. (GET) üîÑ  
- `/adicionar-assento`: Adiciona um novo assento em uma sala espec√≠fica. (POST)  
- `/remover-reserva`: Remover uma reserva realizada. (POST)  
- `/cadastrar-filme`: Adicionar um novo filme no banco de dados. (POST) ‚úÖ  
- `/iarley`:  

---

### Como funciona uma API?

### O que √© Pydantic?

O Pydantic √© uma biblioteca Python para valida√ß√£o de dados baseados em tipagem. Ele permite garantir que os dados que est√£o sendo manipulados atendem a certos tipos e regras de valida√ß√£o, facilitando a constru√ß√£o de APIs e sistemas que lidam com dados.

Por exemplo, o modelo `ReservaRequest` √© uma classe que herda de `BaseModel` do Pydantic, e nela definimos os campos que a requisi√ß√£o de reserva deve ter:

```python
from pydantic import BaseModel

class ReservaRequest(BaseModel):
    usuario_id: int
    agenda_sessao_id: int
    assento_numero: str
```

Assim, se ao realizar uma requisi√ß√£o, algum desses campos contiver algo diferente do esperado, o Pydantic lan√ßa um erro informando qual campo est√° inv√°lido e qual √© o tipo esperado.

Isso torna o c√≥digo mais seguro, pois a valida√ß√£o de tipos √© realizada automaticamente, sem que o desenvolvedor precise escrever manualmente a l√≥gica de valida√ß√£o.

### O que √© Swagger?

J√° o Swagger consiste em uma ferramenta para documentar API‚Äôs, gerando automaticamente a interface de testes.

Por exemplo, ao utilizar FastAPI para criar uma API com este modelo, o Swagger UI √© gerado automaticamente, incluindo todos os campos do modelo `ReservaRequest` na documenta√ß√£o interativa.

Assim, ao acessar `http://localhost:8000/docs`, o Swagger UI mostrar√° algo como:

```json
{
    "usuario_id": 123,
    "agenda_sessao_id": 456,
    "assento_numero": "A10"
}
```

Com isso, o Swagger ajuda os desenvolvedores e usu√°rios da API a entender rapidamente como a API funciona, quais dados s√£o esperados, e quais s√£o os poss√≠veis c√≥digos de resposta.

### Problemas de Concorr√™ncia

Em situa√ß√µes com m√∫ltiplos usu√°rios tentando reservar o mesmo assento, √© poss√≠vel que ocorra uma condi√ß√£o de corrida. Em situa√ß√µes de alta concorr√™ncia, duas transa√ß√µes podiam ler o mesmo estado do assento (dispon√≠vel) e tentar reserv√°-lo ao mesmo tempo, resultando em duplicidade.

Para resolver isso, implementamos transa√ß√µes expl√≠citas e uso de locks pessimistas como veremos a seguir, garantindo atomicidade e isolamento nas opera√ß√µes no Banco.
Solu√ß√£o Proposta

Transa√ß√µes em Banco de Dados devem obedecer aos princ√≠pios ACID, para garantir a integridade e a consist√™ncia dos dados.

    Atomicidade: A transa√ß√£o √© ‚Äútudo ou nada‚Äù. Ou todas as opera√ß√µes s√£o conclu√≠das com sucesso, ou nenhuma √©.

    Consist√™ncia: Ap√≥s a transa√ß√£o, o banco deve permanecer em um estado consistente, respeitando todas as regras e restri√ß√µes definidas.

    Isolamento: Transa√ß√µes simult√¢neas n√£o devem interferir entre si. Cada uma deve parecer ser executada isoladamente.

    Durabilidade: Uma vez confirmadas, as altera√ß√µes da transa√ß√£o persistem no banco mesmo em caso de falha do sistema.

Para garantir que esses princ√≠pios sejam atendidos, implementamos transa√ß√µes expl√≠citas e uso de locks pessimistas.

    (Trecho do C√≥digo)

No trecho de c√≥digo mostrado acima, a transa√ß√£o √© iniciada com conn.begin() e √© encerrada com conn.commit() se tudo correr bem ou conn.rollback() em caso de erro.

O uso expl√≠cito de FOR UPDATE nas consultas impede que outras transa√ß√µes leiam ou escrevam os mesmos registros simultaneamente, aplicando um lock pessimista durante a leitura dos dados cr√≠ticos.

Isso evita condi√ß√µes de corrida, garantindo que duas pessoas n√£o reservem o mesmo assento ao mesmo tempo.